# Property Categorization & Filtering Implementation Plan

## Overview
Implementation plan for categorizing properties (system/custom), filtering by config types through tags, and improving property management UI.

## Core Requirements

### 1. Property Categories
- **System properties** - generated automatically, category: `system`
- **Custom properties** - created manually, category: `custom`
- System properties cannot be deleted
- Custom properties can be fully edited/deleted

### 2. Tags-based Filtering
- Properties have tags indicating where they can be applied
- Filter properties by config type (field, filter, sort) through tags
- Validate property application based on tags

### 3. UI Improvements
- Show tags in property creation/editing
- Visual distinction between system/custom properties
- Enhanced property registry with filtering

## Implementation Plan

### Phase 1: Property Generation Updates (Day 1)

#### 1.1 Update generate-sql-inserts.cjs
```javascript
// Add category and tags to generated properties
const propertyRecord = {
  id: `property_${propName}`,
  type: 'property',
  category: 'system',
  tags: [`applicable_to:field`], // where this property can be used
  data: propertyData,
  caption: `${propName} property`,
  // existing fields...
};
```

#### 1.2 Tags Structure
```javascript
tags: [
  // Applicability tags
  'applicable_to:field',      // can be used in field configs
  'applicable_to:filter',     // can be used in filter configs  
  'applicable_to:sort',       // can be used in sort configs
  
  // Field type specific (optional)
  'field_type:string',        // only for string fields
  'field_type:number',        // only for number fields
  'field_type:boolean',       // only for boolean fields
  
  // System markers
  'system_generated',         // generated by script
  'core_property',            // essential system property
]
```

### Phase 2: UI Category Display (Day 2)

#### 2.1 Visual Distinction in Property Lists
```typescript
// PropertyItem component with category styling
const PropertyItem = ({ property }) => (
  <div className={`
    flex items-center gap-2 p-2 rounded 
    ${property.category === 'system' 
      ? 'bg-gray-50 border-gray-200' 
      : 'bg-blue-50 border-blue-200'
    }
  `}>
    {property.category === 'system' && (
      <Lock className="w-3 h-3 text-gray-500" title="System property" />
    )}
    {property.category === 'custom' && (
      <User className="w-3 h-3 text-blue-500" title="Custom property" />
    )}
    <span className="font-medium">{property.caption}</span>
    <div className="flex gap-1 ml-auto">
      {property.tags?.map(tag => (
        <span key={tag} className="px-1 py-0.5 text-xs bg-white rounded">
          {tag.replace('applicable_to:', '')}
        </span>
      ))}
    </div>
  </div>
);
```

#### 2.2 Property Registry with Filtering
```typescript
// Enhanced Properties panel
const PropertiesPanel = () => {
  const [filterType, setFilterType] = useState<string>('all');
  const [searchTerm, setSearchTerm] = useState('');

  const filteredProperties = useMemo(() => {
    let filtered = properties;
    
    // Filter by config type through tags
    if (filterType !== 'all') {
      filtered = filtered.filter(p => 
        p.tags?.includes(`applicable_to:${filterType}`)
      );
    }
    
    // Search by caption/description
    if (searchTerm) {
      filtered = filtered.filter(p =>
        p.caption?.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    return filtered;
  }, [properties, filterType, searchTerm]);

  return (
    <div>
      {/* Filters */}
      <div className="mb-4 space-y-2">
        <input
          type="text"
          placeholder="Search properties..."
          value={searchTerm}
          onChange={e => setSearchTerm(e.target.value)}
          className="w-full px-3 py-2 border rounded"
        />
        
        <select 
          value={filterType}
          onChange={e => setFilterType(e.target.value)}
          className="w-full px-3 py-2 border rounded"
        >
          <option value="all">All Properties</option>
          <option value="field">Field Properties</option>
          <option value="filter">Filter Properties</option>
          <option value="sort">Sort Properties</option>
        </select>
      </div>

      {/* Grouped properties */}
      <div className="space-y-4">
        <PropertyGroup 
          title="System Properties" 
          properties={filteredProperties.filter(p => p.category === 'system')}
        />
        <PropertyGroup 
          title="Custom Properties" 
          properties={filteredProperties.filter(p => p.category === 'custom')}
        />
      </div>
    </div>
  );
};
```

### Phase 3: Property Creation/Editing (Day 3)

#### 3.1 Enhanced Property Editor
```typescript
// PropertyEditor with category and tags
const PropertyEditor = ({ property, onSave, onCancel }) => {
  const [formData, setFormData] = useState({
    caption: property?.caption || '',
    category: property?.category || 'custom',
    tags: property?.tags || ['applicable_to:field'],
    data: property?.data || {}
  });

  const availableTags = [
    'applicable_to:field',
    'applicable_to:filter', 
    'applicable_to:sort',
    'field_type:string',
    'field_type:number',
    'field_type:boolean',
    'field_type:date'
  ];

  return (
    <div className="space-y-4">
      <input
        type="text"
        placeholder="Property caption"
        value={formData.caption}
        onChange={e => setFormData({...formData, caption: e.target.value})}
      />

      {/* Category (read-only for system) */}
      <div>
        <label>Category</label>
        <select 
          value={formData.category}
          disabled={property?.category === 'system'}
          onChange={e => setFormData({...formData, category: e.target.value})}
        >
          <option value="custom">Custom</option>
          <option value="system">System</option>
        </select>
      </div>

      {/* Tags multi-select */}
      <div>
        <label>Applicable to (Tags)</label>
        <TagMultiSelect
          options={availableTags}
          value={formData.tags}
          onChange={tags => setFormData({...formData, tags})}
        />
      </div>

      {/* Property data editor */}
      <PropertyDataEditor 
        value={formData.data}
        onChange={data => setFormData({...formData, data})}
      />
    </div>
  );
};
```

### Phase 4: System Property Protection (Day 4)

#### 4.1 Delete Protection
```typescript
// Prevent deletion of system properties
const handleDeleteProperty = (propertyId: string) => {
  const property = properties.find(p => p.id === propertyId);
  
  if (property?.category === 'system') {
    alert('System properties cannot be deleted');
    return;
  }
  
  if (confirm('Are you sure you want to delete this custom property?')) {
    deleteProperty(propertyId);
  }
};
```

#### 4.2 Edit Restrictions
```typescript
// Limit what can be edited for system properties
const getEditableFields = (property) => {
  if (property.category === 'system') {
    return ['data', 'override_data']; // only data can be modified
  }
  return ['caption', 'category', 'tags', 'data', 'override_data']; // all fields
};
```

### Phase 5: Drag&Drop Validation (Day 5)

#### 5.1 Property Application Validation
```typescript
// Validate property can be applied to config type
const canApplyProperty = (property: Property, targetConfig: Config): boolean => {
  const configType = targetConfig.type;
  
  // Check if property is applicable to this config type
  if (!property.tags?.includes(`applicable_to:${configType}`)) {
    return false;
  }
  
  // Additional validation for field configs
  if (configType === 'field') {
    const fieldType = targetConfig.data?.fieldType;
    
    // If property has field type restrictions
    const fieldTypeRestrictions = property.tags?.filter(t => t.startsWith('field_type:'));
    if (fieldTypeRestrictions.length > 0) {
      return fieldTypeRestrictions.includes(`field_type:${fieldType}`);
    }
  }
  
  return true;
};

// Enhanced drop handler
const handlePropertyDrop = (propertyId: string, targetConfigId: string) => {
  const property = properties.find(p => p.id === propertyId);
  const targetConfig = configs.find(c => c.id === targetConfigId);
  
  if (!canApplyProperty(property, targetConfig)) {
    const configType = targetConfig.type;
    alert(`Property "${property.caption}" cannot be applied to ${configType} configs`);
    return;
  }
  
  // Proceed with adding property
  addPropertyToConfig(propertyId, targetConfigId);
};
```

## Data Structure Changes

### Updated Property Interface
```typescript
interface Property {
  id: string;
  type: 'property';
  caption: string;
  category: 'system' | 'custom';
  tags: string[];                    // NEW: applicability tags
  data: any;
  override_data?: any;
  created_at: string;
  updated_at: string;
  created_by?: string;               // NEW: for custom properties
  version?: number;                  // NEW: for versioning
}
```

### Example Property Records
```javascript
// System property (generated)
{
  id: 'property_required',
  type: 'property', 
  category: 'system',
  tags: ['applicable_to:field', 'system_generated'],
  caption: 'Required field property',
  data: { required: true }
}

// Custom property (user created)
{
  id: 'property_custom_validation',
  type: 'property',
  category: 'custom', 
  tags: ['applicable_to:field', 'field_type:string'],
  caption: 'Email validation',
  data: { validation: { pattern: '^[^@]+@[^@]+\.[^@]+$' } },
  created_by: 'user123'
}
```

## Benefits

1. **Clear Organization** - System vs custom properties clearly distinguished
2. **Safer Operations** - System properties protected from accidental deletion
3. **Better UX** - Only show applicable properties for each config type
4. **Validation** - Prevent incompatible property assignments
5. **Searchability** - Find properties quickly by name and function
6. **Maintainability** - Clear separation of generated vs manual properties

## Future Enhancements (Deferred)

### ðŸš« Property Templates (Deferred)
**Reason**: Can be achieved through template configs with properties
**Future approach**: Create template configs that include property sets

### âœ… Existing Features (To Verify)
- **Search functionality** - Already exists, verify implementation
- **Property versioning** - Check if version field already exists

## Implementation Schedule

- **Day 1**: Update property generation script with categories/tags
- **Day 2**: Implement UI visual distinctions and filtering  
- **Day 3**: Enhanced property editor with tags
- **Day 4**: System property protection
- **Day 5**: Drag&drop validation and testing

## Success Criteria

- âœ… System properties have category='system' and appropriate tags
- âœ… Custom properties created with category='custom'
- âœ… System properties cannot be deleted
- âœ… Property filtering by config type works
- âœ… Visual distinction between property types
- âœ… Drag&drop validation prevents invalid assignments
- âœ… Search and filtering work smoothly
- âœ… All existing functionality preserved

## Testing Plan

1. **Property Generation**: Verify all generated properties have correct categories/tags
2. **UI Filtering**: Test filtering by field/filter/sort types
3. **Protection**: Confirm system properties cannot be deleted
4. **Validation**: Test drag&drop prevents invalid property assignments
5. **Custom Properties**: Create/edit/delete custom properties
6. **Performance**: Ensure filtering doesn't impact performance with many properties